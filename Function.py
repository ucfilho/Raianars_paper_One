# -*- coding: utf-8 -*-
"""Untitled15.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qt7MJ15XSZDCwxu5_FYJooacsXdJh6n9
"""

# -*- coding: utf-8 -*-
"""
Created on Fri Aug 11 00:01:34 2017
@author: raiana
"""
import numpy as np
from math import *
   

################################### Funções unimodais
    
'''Rosembrock Function'''
def Rosenbrock(x):
    fun=0
    for i in range(len(x)-1):
        fun = 100*(x[i]-x[i-1]**2)**2 + (1-x[i-1])**2
    return fun 

#Rosembrock_domain=[-30,30]
# Global Minimum: 0

def Sphere(x):
    return sum([i**2 for i in x])
# f(x)=0 x=(0,0) [-5.12,5.12]

def Sum_of_different_powers(x):
    return sum([abs(x[i])**(i+2) for i in range(len(x))])
# f(x)=0 x=(0,0) [-1,1]

def Easom(x):
    return -cos(x[0])*cos(x[1])*exp(-(x[0] - pi)**2 - (x[1] - pi)**2)
# f(x)=-1 x=(pi,pi) [-100,100]

def Booth(x):
    return (x[0] + 2*x[1] - 7)**2 + (2*x[0] + x[1] - 5)**2
# f(x)=0 x=(1,3) [-10,10]
    
def Beale(x):
    return (1.5 - x[0] + x[0]*x[1])**2 + (2.25 - x[0] + x[0]*x[1]**2)**2 + \
           (2.625 - x[0] + x[0]*x[1]**3)**2

### Unimodais parecidas

def bohachevsky_function(x): #gráfico parecido c a espera
    return x[0]**2 + 2*x[1]**2 - 0.3*cos(3*pi*x[0]) - 0.4*cos(4*pi*x[1]) + 0.7

def sum_squares_function(x): #gráfico parecido c a espera
    return sum([(i+1)*x[i]**2 for i in range(len(x))])

def matyas_function(x): #parece booth (papel)
    return 0.26*sphere_function(x) - 0.48*x[0]*x[1]

def mccormick_function(x): #parece booth (papel)
    return sin(x[0] + x[1]) + (x[0] - x[1])**2 - 1.5*x[0] + 2.5*x[1] + 1

def dixon_price_function(x): #sum_of_different_powers_function
    return (x[0] - 1)**2 + sum([(i+1)*(2*x[i]**2 - x[i-1])**2
                                for i in range(1, len(x))])

def three_hump_camel_function(x):  #sum_of_different_powers_function
    return 2*x[0]**2 - 1.05*x[0]**4 + x[0]**6/6 + x[0]*x[1] + x[1]**2


############################################################################

###################################Funções multimodais
    
def Rastrigin(args):
    f = 10 * len(args) + sum([np.power(x, 2.) - 10 * np.cos(2 * np.pi * x) for x in args])
    return f
# f(x)=0 x=(0,0) [-5.12,5.12]

'''Schubert Function'''

def Shubert(x):
    n=1
    sum1=0
    sum2=0
    for n in range(1,6):
        new1=(n*np.cos((n+1)*x[0]+n))
        new2=(n*np.cos((n+1)*x[1]+n))
        sum1=sum1+new1
        sum2=sum2+new2
    return (sum1*sum2+186.7309)

# Domain: xi ∈  [-10,10]
# Global Minimum: -186.7309
 
'''Schwefel Function'''

def Schwefel(x):
    
    summ=0
    for i in range(len(x)):
        new=x[i]*np.sin((abs(x[i]))**0.5)
        summ=summ+new
#        print(summ)
    #return (418.9829*len(x)-summ)
    return (418.982887272433799807913601398*len(x)-summ)

# Global optimum: f(xi)= 0 for xi = 420.968746 for i=1,...,n  ;  xi in [-500,500] 
    
def Ackley(x):
    return -20*exp(-0.2*sqrt(1/len(x)*sum([i**2 for i in x]))) - \
           exp(1/len(x)*sum([cos(2*np.pi*i) for i in x])) + 20 + exp(1)
 # f(x)=0 x=(0,0) [-32, 32]

def Bukin(x):
    return 100*sqrt(abs(x[1]-0.01*x[0]**2)) + 0.01*abs(x[0] + 10)
# f(X)=0, x=(-10,1)    x_1∈[-15.-5]  x2 ∈ [-3, 3]. 

def Cross_in_tray(x):
    return round(-0.0001*(abs(sin(x[0])*sin(x[1])*exp(abs(100 -
                            sqrt(sum([i**2 for i in x]))/pi))) + 1)**0.1, 7)
#fx--2.06261 x=( +/-1.3491.+/-1.3491) [-10,10]
def Michalewicz(x):
    return -sum([sin(x[i])*sin((i)*x[i]**2/pi)**20 for i in range(len(x))])
#fx=-9.66015 d=10 [0,pi]

def Drop_wave(x):
    return -(1 + cos(12*sqrt(sphere_function(x))))/(0.5*sphere_function(x) + 2)
#

def Six_hump_camel(x): 
    return (4 - 2.1*x[0]**2 + (x[0]**4)/3)*x[0]**2 + x[0]*x[1]\
           + (-4 + 4*x[1]**2)*x[1]**2
#fx=-1.0316 ; x=(+-0.0898,+-0.7126) x1 ∈ [-3, 3], x2 ∈ [-2, 2].

############################################################################

################################### Novas Funções 
# funoces atualizadas em dez 02 2019
# Implemented functions:
# Alpine N2                   : multi     :    non-convex   
# Griewank Function           : UNIMODAL  :    non-convex 
# HappyCat function           : multi     :    non-convex 
# Periodic function           : multi     :    non-convex 
# Qing Function               : multi     :    non-convex 
# Ridge function              : UNIMODAL  :    non-convex 
# Salomon function            : multi     :    non-convex 
# Styblinskitank function     : multi     :    non-convex 
# Shubert function            : multi     :    non-convex 
# Shubert3 function           : multi     :    non-convex 
# Xin-She Yang N. 3 Function  : UNIMODAL  :    non-convex 
# Zakharov Function           : UNIMODAL  :    convex

def alpinen2(x):
  prod=1
  for i in x:
    prod=prod*(i**0.5*np.sin(i))
  return prod*(-1)

def Griewank(x):
  prod_cosx_i05=1
  sumx1=0
  sumx2=0
  i=0
  for k in x:
    i=i+1
    sumx1=sumx1+k
    sumx2=sumx2+k*k
    prod_cosx_i05=prod_cosx_i05*np.cos(k/(i**0.5))
  return 1+sumx2/4000 - prod_cosx_i05

def HappyCat(x): 
    alpha=1. / 8
    s = sum(x**2) 
    return ((s - len(x))**2)**alpha + (s / 2 + sum(x)) / len(x) + 0.5

def Periodic(x):
  sumx2=0
  sin2x=0
  for i in x:
    sumx2=sumx2+i**2
    sin2x=sin2x+(np.sin(i))**2
  return 1+sin2x-0.1*np.exp(-sumx2)

def Qing(x):
  sumx2_i_2=0
  i=0
  for k in x:
    i=i+1
    sumx2_i_2=sumx2_i_2+(k**2-i)**2
  return sumx2_i_2

def ridge(x):
  soma=0
  d=2
  alpha=0.1
  for i in x:
    soma=soma+i**2
  soma=soma-x[0]**2
  return x[0]+d*soma**(alpha)

def Salomon(x):
  sumx2=0
  sqrtsx2=0
  for i in x:
    sumx2=sumx2+i**2
  sqrtsx2=sumx2**0.5

  return 1-np.cos(2*np.pi*sqrtsx2)+(0.1 * sqrtsx2)

def Styblinskitank(x):
  sumx1=0
  sumx2=0
  sumx4=0
  for i in x:
    sumx1=sumx1+i
    sumx2=sumx2+i**2
    sumx4=sumx4+i**4
  return sumx4-16*sumx2+5*sumx1

def Shubert(x):
  prod=1

  for i in x:
    sum_eq=0
    for k in range(5):
      j=k+1
      sum_eq=sum_eq+np.cos(((j + 1) * i) + j)
    prod=prod*sum_eq
  return prod

def Shubert3(x):
  soma=0

  for i in x:
    for k in range(5):
      j=k+1
      soma=soma +j * np.sin(((j + 1) * i) + j)

  return soma


def XinSheYang(x):
  m=5
  b=15
  sumx_b_2m=0
  sumx2=0
  prod_cos2x=1
  for k in x:
    sumx2=sumx2+k*k
    sumx_b_2m=sumx_b_2m+(k/b)**(2*m)
    prod_cos2x=prod_cos2x*np.cos(k)**2
  return np.exp(-sumx_b_2m)-2*np.exp(-sumx2)*prod_cos2x

def Zakharov(x):
  sumx2=0
  sum_05ix=0
  i=0
  for k in x:
    i=i+1
    sumx2=sumx2+k**2
    sum_05ix=sum_05ix+0.5*i*k
  return sumx2+ (sum_05ix)**2+ (sum_05ix)**4
